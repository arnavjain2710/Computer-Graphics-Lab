# -*- coding: utf-8 -*-
"""220002018 - Set C

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kP7gnC31qxc_kXTfd6n36vf0VlaLIS7w

## Question - 1
"""

import numpy as np
import matplotlib as plt

def to_homogeneous(x , y , z):
  homogeneous_coords = np.array([x, y, z, 1])
  return homogeneous_coords

def scaling_matrix(sx, sy, sz):
  return np.array([
      [sx, 0, 0, 0],
      [0, sy, 0, 0],
      [0, 0, sz, 0],
      [0, 0, 0, 1]
  ])

def translation_matrix(tx, ty, tz):
  return np.array([
      [1, 0, 0, tx],
      [0, 1, 0, ty],
      [0, 0, 1, tz],
      [0, 0, 0, 1]
  ])

def rotation_matrix(angle, axis):
  c = np.cos(angle)
  s = np.sin(angle)

  if axis == 'x':
    return np.array([
        [1, 0, 0, 0],
        [0, c, -s, 0],
        [0, s, c, 0],
        [0, 0, 0, 1]
    ])
  elif axis == 'y':
    return np.array([
        [c, 0, s, 0],
        [0, 1, 0, 0],
        [-s, 0, c, 0],
        [0, 0, 0, 1]
    ])
  elif axis == 'z':
    return np.array([
        [c, -s, 0, 0],
        [s, c, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
    ])

x , y , z = 3 , -1 , 4
print(f"Original Point :{x},{y},{z}")
homogenous_point = to_homogeneous(x , y , z)
print(homogenous_point)

scaling_matrix = scaling_matrix(1.5, 2.0, 0.5)
print(scaling_matrix)

rotation_matrix = rotation_matrix(45 , 'y')
print(rotation_matrix)

translation_matrix = translation_matrix(-1, 3, 6)
print(translation_matrix)

composite_matrix = translation_matrix @ rotation_matrix @ scaling_matrix
print(composite_matrix)

transformed_point = composite_matrix @ homogenous_point
print(transformed_point)

scaled_point = scaling_matrix @ homogenous_point
rotated_point = rotation_matrix @ scaled_point
translated_point = translation_matrix @ rotated_point

print(scaled_point)
print(rotated_point)
print(translated_point)

# Visualization
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

points = {
    'Original': homogenous_point[:3],
    'Scaled': scaled_point[:3],
    'Rotated': rotated_point[:3],
    'Translated': translated_point[:3]
}

colors = {'Original': 'blue', 'Scaled': 'green', 'Rotated': 'red', 'Translated': 'purple'}
markers = {'Original': 'o', 'Scaled': '^', 'Rotated': 's', 'Translated': '*'}

for label, pt in points.items():
    ax.scatter(*pt, color=colors[label], marker=markers[label], s=100, label=label)
    ax.plot([0, pt[0]], [0, pt[1]], [0, pt[2]],
            color=colors[label], linestyle='dashed', alpha=0.3)

ax.set_xlim([-5, 20])
ax.set_ylim([-10, 10])
ax.set_zlim([0, 15])
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend(loc='upper left')
plt.title('Composite Transformation: Scaling → Rotation → Translation')
plt.show()

# Visualization
fig = plt.figure(figsize=(10, 8))
ax = fig.add_subplot(111, projection='3d')

points = {
    'Original': homogenous_point[:3],
    'Transformed': transformed_point[:3]
}

colors = {'Original': 'blue','Transformed': 'purple'}
markers = {'Original': 'o', 'Transformed': '*'}

for label, pt in points.items():
    ax.scatter(*pt, color=colors[label], marker=markers[label], s=100, label=label)
    ax.plot([0, pt[0]], [0, pt[1]], [0, pt[2]],
            color=colors[label], linestyle='dashed', alpha=0.3)

ax.set_xlim([-5, 20])
ax.set_ylim([-10, 10])
ax.set_zlim([0, 15])
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('Z')
ax.legend(loc='upper left')
plt.title('Combined Transformation')
plt.show()

print("Original Point:", homogenous_point[:3])
print("Scaled Point:", scaled_point[:3])
print("Rotated Point:", rotated_point[:3])
print("Translated Point:", translated_point[:3])
print("Final Transformed Point:", transformed_point[:3])

"""## Question - 2"""

import matplotlib.pyplot as plt
import numpy as np

def drawline(p0, p1):
    plt.plot([p0[0], p1[0]], [p0[1], p1[1]], 'k-')

def drawPolygon(vertices):
    vertices.append(vertices[0])
    xs, ys = zip(*vertices)
    plt.fill(xs, ys, edgecolor='r', fill=False)

def dot(p0, p1):
    return p0[0] * p1[0] + p0[1] * p1[1]

def max(t):
    return np.max(t)

def min(t):
    return np.min(t)

# Cyrus Beck function
def CyrusBeck(vertices, line):
    n = len(vertices)
    P1_P0 = (line[1][0] - line[0][0], line[1][1] - line[0][1])
    normal = [(vertices[i][1] - vertices[(i + 1) % n][1], vertices[(i + 1) % n][0] - vertices[i][0]) for i in range(n)]
    P0_PEi = [(vertices[i][0] - line[0][0], vertices[i][1] - line[0][1]) for i in range(n)]
    numerator = [dot(normal[i], P0_PEi[i]) for i in range(n)]
    denominator = [dot(normal[i], P1_P0) for i in range(n)]
    t = [numerator[i] / denominator[i] if denominator[i] != 0 else 0 for i in range(n)]
    tE = [t[i] for i in range(n) if denominator[i] > 0]
    tL = [t[i] for i in range(n) if denominator[i] < 0]
    tE.append(0)
    tL.append(1)
    print(f"Parametric Values entering the Polygon: {tE}")
    print(f"Parametric Values leaving the Polygon: {tL}")
    temp = [max(tE), min(tL)]
    if temp[0] > temp[1]:
        return None

    # New Line Co ordinates
    newPair = [(line[0][0] + P1_P0[0] * temp[0], line[0][1] + P1_P0[1] * temp[0]),
               (line[0][0] + P1_P0[0] * temp[1], line[0][1] + P1_P0[1] * temp[1])]
    print(f"New Coordinates: {newPair}")
    return newPair

def plotting(vertices , line):
    plt.figure(figsize=(6, 6))
    plt.title('Before Clipping')
    drawPolygon(vertices)
    drawline(line[0], line[1])
    plt.xlim(0, 20)
    plt.ylim(0, 20)
    plt.show()

    newPair = CyrusBeck(vertices, line)
    if newPair is not None:
        plt.figure(figsize=(6, 6))
        plt.title('After Clipping')
        drawPolygon(vertices)
        drawline(newPair[0], newPair[1])
        plt.xlim(0, 20)
        plt.ylim(0, 20)
        plt.show()

vertices = [(2, 1), (7,1,), (9,5), (6, 8), (3, 6)]
line = [(3,2), (11,9)]
plotting(vertices , line)